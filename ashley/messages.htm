<!DOCTYPE html>
<html>
    <head>
        <title>Ashley Messages</title>
        <link href='https://fonts.googleapis.com/css?family=Roboto' rel='stylesheet'>
        <link rel="stylesheet" href="css/mvp.css">
        <link rel="stylesheet" href="css/site.css">
    </head>
    <body>
        <script src="../scripts/html_tools.js"></script>
        <script src="../scripts/string_tools.js"></script>
        <script>
            // Old list from 2020:
            // https://jennacitrus.wordpress.com/2020/04/25/onlyfans-list-of-restricted-words/
            // Some words are allowed now, like 'golden' but I am leaving them visible
            // (but commented out) for posterity. I have also added new words (like 'companion')
            // that didn't appear in the blog post originally.
            const restrictedWords = [
                `abduct`,
                `abducted`,
                `abducting`,
                `abduction`,
                `admireme`,
                `animal`,
                `asphyxia`,
                `asphyxiate`,
                `asphyxiation`,
                `asphyxicate`,
                `asphyxication`,
                `bait`,
                `ballbusting`,
                `bareback`,
                `beastiality`,
                `bestiality`,
                `blacked`,
                `blackmail`,
                `bleeding`,
                `blood`,
                `bloodplay`,
                `bukkake`,
                `caned`,
                `caning`,
                `cannibal`,
                `cbt`,
                `cervics`,
                `cerviks`,
                `cervix`,
                `child`,
                `chloroform`,
                `chloroformed`,
                `chloroforming`,
                `choke`,
                `choking`,
                `coma`,
                `comatose`,
                `companion`,
                `consent`,
                `cp`,
                `cycle`,
                `diapers`,
                `dog`,
                `doze`,
                `drinking`,
                `drunk`,
                `drunken`,
                `enema`,
                `entrance`,
                `escort`,
                `escorting`,
                `fanfuck`,
                `farm`,
                `fecal`,
                `fetal`,
                `fisted`,
                `fisting`,
                `flogging`,
                `foetal`,
                `forced`,
                `forcedbi`,
                `forceful`,
                `forcing`,
                `fuckafan`,
                `fuckfan`,
                `gangbang`,
                `gangbangs`,
                `gaping`,
                //`golden`,
                `hardsports`,
                `hooker`,
                `hypno`,
                `hypnotize`,
                `hypnotized`,
                `hypnotizing`,
                `inbreed`,
                `inbreeded`,
                `inbreeding`,
                `incapacitate`,
                `incapacitation`,
                `incest`,
                `intox`,
                `inzest`,
                `jail`,
                `jailbait`,
                `kidnap`,
                `kidnapped`,
                `kidnapping`,
                `knock`,
                `knocked`,
                `lactate`,
                `lactation`,
                `lolicon`,
                `lolita`,
                `medicalplay`,
                `menstrate`,
                `menstrual`,
                `menstruate`,
                `menstruating`,
                `menstruation`,
                `meet`,
                `molest`,
                `molested`,
                `molesting`,
                `mutilate`,
                `mutilation`,
                `necrophilia`,
                `nigger`,
                `paddling`,
                `paralyzed`,
                `passed`,
                `pedo`,
                `pedophile`,
                `pedophilia`,
                `pee`,
                `peeplay`,
                `pegging`,
                `piss`,
                `pissing`,
                `poo`,
                `poop`,
                `preteen`,
                `prostituted`,
                `prostituting`,
                `prostitution`,
                `pse`,
                `rape`,
                `raping`,
                `rapist`,
                `restrictedwordtestzulu`,
                `scat`,
                `showers`,
                `skat`,
                `snuff`,
                `strangled`,
                `strangling`,
                `strangulation`,
                `suffocate`,
                `suffocation`,
                `teen`,
                `toilet`,
                `toiletslave`,
                `toiletslavery`,
                `torture`,
                `tortured`,
                `trance`,
                `unconscious`,
                `unconsciousness`,
                `underage`,
                `unwilling`,
                `vomit`,
                `vomitted`,
                `vomitting`,
                `watersports`,
                `whipping`,
                `young`,
                `zoophilia`,
            ];

            function BadRando(state) {
                const date = new Date();
                const hour = date.getHours();
                const dayNum = date.getDay() + 1;
                const day = date.getDate();
                const isWeekend = dayNum === 1 || dayNum === 7;

                this.isMorning = hour < 12;
                this.isAfternoon = hour >= 12 && hour < 17;
                this.isEvening = hour >= 17;
                
                //Terms of endearment for the bedtime message.
                //Ensures three unique terms are used.
                //Yes, it could be an array/collection. It's not.
                //I have my reasons, you have yours.
                let usedTerm0 = '';
                let usedTerm1 = '';
                let usedTerm2 = '';

                const rnd = () => Math.random();

                function monthDiff(d1, d2) {
                    let months = (d2.getFullYear() - d1.getFullYear()) * 12;
                    months -= d1.getMonth();
                    months += d2.getMonth();
                    return months <= 0 ? 0 : months;
                }

                this.getGoodMorning = () => {
                    switch (dayNum) {
                        case 1:
                        case 3:
                        case 6:
                            return `Good morning gorgeous.`;
                        default:
                            return `Good morning beautiful.`;
                    }
                };

                this.getILoveYou = () => {
                    if (Math.floor(rnd() * 4) === 1) {
                        const phrases = [
                            `I love you *so* much.`,
                            `I love you dearly.`,
                            `I love you immensely.`,
                            `I love you forever.`,
                        ];
                        return phrases[Math.floor(rnd() * phrases.length)];
                    }
                    return `I love you.`;
                };

                this.getQuestions = () => {
                    let msg = ``;
                    //0: is it the 19th?
                    if (day === 19) {
                        const chattingSince = new Date(2023, 3, 19);
                        const diffMonths = monthDiff(chattingSince, date);
                        if (diffMonths % 12 === 0) {
                            //anniversary
                            const numYears = diffMonths / 12;
                            const yearOrYears = numYears === 1 ? 'year' : 'years';
                            const cardinals = [
                                `first`,
                                `second`,
                                `third`,
                                `fourth`,
                                `fifth`,
                                `sixth`,
                                `seventh`,
                                `eighth`,
                                `ninth`,
                                `tenth`,
                            ];
                            const endearment = [
                                'Tonia',
                                'princess',
                                'baby girl',
                                'babe',
                            ];
                            const adjectives = [
                                'amazing',
                                'incredible',
                                'beautiful',
                                'wonderful',
                                'spectacular',
                            ];
                            const adj = adjectives[Math.floor(rnd() * adjectives.length)];
                            const statement = `Happy ${cardinals[numYears-1]} anniversary ${endearment[Math.floor(rnd() * endearment.length)]}!`;
                            const additions = [
                                `Can you believe it's been a whole ${numYears} ${yearOrYears} since we started chatting?`,
                                `It's been ${numYears} ${adj} ${yearOrYears} of chatting and growing our beautiful friendship.`,
                                `I have loved every second of the ${numYears} ${adj} ${yearOrYears} that we've known each other.`,
                                `I love that we have been chatting for ${numYears} ${adj} ${yearOrYears}!`,
                            ];
                            const yearEmojis = [
                                `ðŸŒ¹ðŸŒ¹ðŸŒ¹ðŸŒ¹ðŸŒ¹ðŸŒ¹ðŸŒ¹ðŸŒ¹ðŸŒ¹ðŸŒ¹ðŸŒ¹ðŸŒ¹`,
                                `ðŸŒºðŸŒºðŸŒºðŸ’ðŸ’ðŸ’ðŸŒºðŸŒºðŸŒº`,
                                `ðŸ¾ðŸ¥‚â¤ï¸ðŸ’‹ðŸ«¶ðŸ’ðŸ¤—ðŸ˜˜`,
                            ];
                            msg += `${statement} ${additions[Math.floor(rnd() * additions.length)]} ${yearEmojis[Math.floor(rnd() * yearEmojis.length)]} `;
                        }
                        else{
                            //monthiversary
                            const monthOrMonths = diffMonths === 1 ? 'month' : 'months';
                            const monthiversary = [
                                `Happy ${diffMonths} ${monthOrMonths} day!`,
                                `Can you believe it's already been ${diffMonths} ${monthOrMonths} since we've been talking babe?`,
                                `Happy ${diffMonths} ${monthOrMonths} day babe!`,
                                `It's been another wonderful month of chatting with my favorite person! Happy ${diffMonths} ${monthOrMonths} day babe!`,
                                `Happy ${diffMonths} ${monthOrMonths} day Tonia!`,
                            ];
                            const monthEmojis = [
                                `â¤ï¸â¤ï¸â¤ï¸`,
                                `ðŸŒºðŸŒ¹ðŸ’`,
                                `ðŸ’–ðŸ¥°ðŸ˜š`,
                            ];
                            msg += `${monthiversary[Math.floor(rnd() * monthiversary.length)]} ${monthEmojis[Math.floor(rnd() * monthEmojis.length)]} `;
                        }
                    }

                    //1: how are you feeling today variations
                    const howFeeling = [
                        `How are you feeling today babe?`,
                        `How are you feeling today baby girl?`,
                        `How is my princess feeling today?`,
                        `How are you feeling babe?`,
                        `How are you feeling today princess?`,
                        `How are you feeling baby girl?`,
                    ];
                    msg += howFeeling[Math.floor(rnd() * howFeeling.length)];
                    //2: how was your morning variations
                    const morning = [
                        `How has your day been so far?`,
                        `How's the day been treating you?`,
                        `How was your morning?`,
                        `How's the morning been treating you?`,
                        `How has the day been treating you?`,
                        `How was your morning?`,
                        `How did the morning treat you?`,
                        `How did your morning go?`,
                    ];
                    msg += ' ' + morning[Math.floor(rnd() * morning.length)];
                    //3: up to 1 optional question about class, work, kaj, life, etc.
                    if (Math.floor(rnd() * 5) > 2) {
                        const optional = [];
                        optional.push(`How is Kaj doing today?`);
                        if (!isWeekend) {
                            optional.push(`How has class been today?`);
                            optional.push(`How is class treating you?`);
                            optional.push(`How have classes been going?`);
                            optional.push(`How is class going?`);
                        }
                        optional.push(`Has anything interesting happened yet today?`);
                        optional.push(`Anything interesting happening today?`);
                        optional.push(`Have you done anything interesting yet today?`);
                        optional.push(`Have you done anything fun yet today?`);
                        optional.push(`Anything fun going on today?`);
                        if (isWeekend) {
                            optional.push(`Any plans today?`);
                            optional.push(`Do you have anything fun planned for today?`);
                            optional.push(`What will you be doing today?`);
                            optional.push(`Do you have anything interesting planned for today?`);
                            optional.push(`What do you have to do today?`);
                            optional.push(`Any fun plans today?`);
                            optional.push(`What plans do you have today?`);
                            optional.push(`Any interesting plans today?`);
                            optional.push(`Did you get breakfast with your friend this morning?`);
                        }
                        optional.push(`How has work been?`);
                        optional.push(`How has work been going?`);
                        optional.push(`How has work been lately?`);
                        optional.push(`How is work going?`);
                        optional.push(`Anything interesting happening with work?`);
                        msg += ' ' + optional[Math.floor(rnd() * optional.length)];
                    }
                    return msg;
                };

                this.getAudioClipQuestion = () => {
                    const options = [
                        'Silly',
                        'Sweet',
                        'Salty',
                        'Spicy',
                        'Bitter',
                        'Oily',
                    ];
                    const reorderedOptions = [];
                    let msg = '';
                    let listOptions = '';
                    while (options.length > 0) {
                        const opt = options.splice(Math.floor(rnd() * options.length), 1)[0];
                        reorderedOptions.push(opt);
                        if (options.length > 0) {
                            listOptions += opt.toLowerCase() + ', ';
                        }
                        else {
                            listOptions += `or ${opt.toLowerCase()}`;
                        }
                    }
                    const individualOptionQuestions = reorderedOptions.map(o => `${o}?`).join(' ');
                    const aOrAn = listOptions.indexOf('o') === 0 ? 'an' : 'a';

                    if (Math.floor(rnd() * 10) % 3 === 0) {
                        const single = [
                            `For your audio clip this evening would you like something ${listOptions}?`,
                            `Would you like ${aOrAn} ${listOptions} audio clip this evening?`,
                            `Are you in the mood for something ${listOptions} this evening?`,
                        ];
                        msg = single[Math.floor(rnd() * single.length)];
                    }
                    else {
                        //two sentence options
                        const opening = [
                            `What kind of clip are you in the mood for this evening babe?`,
                            `What kind of audio clip would you like?`,
                            `How will you take your evening audio clip tonight?`,
                            `What kind of audio clip are you in the mood for?`,
                            `What *flavor* of audio clip shall I serve for you tonight princess?`,
                            `What kind of audio clip would you like this evening babe?`,
                        ];
                        const ending = [
                            `${individualOptionQuestions}`,
                            `${capitalizeFirstLetter(listOptions)}?`,
                            `Something ${listOptions}?`,
                        ];

                        msg = `${opening[Math.floor(rnd() * opening.length)]} ${ending[Math.floor(rnd() * ending.length)]}`;
                    }

                    if (Math.floor(rnd() * 10) % 3 > 0) {
                        if (Math.floor(rnd() * 10) % 2 === 0) {
                            msg += ' ðŸ˜˜';
                        }
                        else {
                            msg += ' ðŸ¥°';
                        }
                    }

                    return msg;
                };

                this.getBedtimeTitles = () => {
                    const firstWord = [
                        'Oh',
                        'My',
                        'Oh my',
                    ];
                    const descriptors = [
                        'Amazing',
                        'Awesome',
                        'Beautiful',
                        'Beloved',
                        'Brilliant',
                        'Charming',
                        'Dazzling',
                        'Dear',
                        'Delicate',
                        'Delightful',
                        'Divine',
                        'Enchanting',
                        'Exquisite',
                        'Fantastic',
                        'Fascinating',
                        'Gorgeous',
                        'Hot',
                        'Incredible',
                        'Lovely',
                        'Magnificent',
                        'Precious',
                        'Radiant',
                        'Ravishing',
                        'Sensational',
                        'Sexy',
                        'Spectacular',
                        'Stunning',
                        'Sweet',
                        'Wonderful',
                    ];
                    const mostUpgrade = {
                        'Amazing': 'Most amazing',
                        'Awesome': 'Most awesome',
                        'Beautiful': 'Most beautiful',
                        'Beloved': 'Most beloved',
                        'Brilliant': 'Most brilliant',
                        'Charming': 'Most charming',
                        'Dazzling': 'Most dazzling',
                        'Dear': 'Dearest',
                        'Delicate': 'Most delicate',
                        'Delightful': 'Most delightful',
                        'Divine': 'Most divine',
                        'Enchanting': 'Most enchanting',
                        'Exquisite': 'Most exquisite',
                        'Fantastic': 'Most fantastic',
                        'Fascinating': 'Most fascinating',
                        'Gorgeous': 'Most gorgeous',
                        'Hot': 'Hottest',
                        'Incredible': 'Most incredible',
                        'Lovely': 'Loveliest',
                        'Magnificent': 'Most magnificent',
                        'Precious': 'Most precious',
                        'Radiant': 'Most radiant',
                        'Ravishing': 'Most ravishing',
                        'Sensational': 'Most sensational',
                        'Sexy': 'Sexiest',
                        'Spectacular': 'Most spectacular',
                        'Stunning': 'Most stunning',
                        'Sweet': 'Sweetest',
                        'Wonderful': 'Most wonderful',
                    };
                    //Note: repeats are on purpose to make them slightly more common.
                    const endearment = [
                        'Tonia',
                        'princess',
                        'baby girl',
                        'best friend',
                        'favorite person',
                        'Tonia',
                        'princess',
                        'baby girl',
                        'favorite human being',
                        'queen of babes',
                        'goddess of beauty',
                        'mother of canines',
                        'Tonia',
                        'princess',
                        'baby girl',
                        'keeper of my heart',
                        'princess of my heart',
                    ];
                    //Remove used terms of endearment.
                    if (usedTerm1.length > 0 && endearment.indexOf(usedTerm1) > -1) {
                        endearment.splice(endearment.indexOf(usedTerm1), 1);
                    }
                    if (usedTerm2.length > 0 && endearment.indexOf(usedTerm2) > -1) {
                        endearment.splice(endearment.indexOf(usedTerm2), 1);
                    }

                    //get the descriptors
                    const desc = [];
                    let n = 0;
                    do {
                        let d = descriptors.splice(Math.floor(rnd() * descriptors.length), 1)[0];
                        if (Math.floor(rnd() * 67) > 50 && mostUpgrade.hasOwnProperty(d)) {
                            d = mostUpgrade[d];
                        }
                        if (n > 0) {
                            d = d.toLowerCase();
                        }
                        desc.push(d);
                    } while ((Math.floor(rnd() * 4) > n++));

                    //if only two desc, joining with a , is optional
                    let descChain = '';
                    if (desc.length == 2 && Math.floor(rnd() * 100) % 4 === 0) {
                        descChain = desc.join(' ');
                    }
                    else {
                        descChain = desc.join(', ');
                    }

                    usedTerm0 = endearment[Math.floor(rnd() * endearment.length)];
                    const legalFirstWord = (usedTerm0.toLowerCase().indexOf('favorite') > -1 || usedTerm0.toLowerCase().indexOf('best') > -1)
                        ? firstWord.filter(x => x.toLowerCase().indexOf('my') > -1)
                        : (usedTerm0.toLowerCase().indexOf('my') > -1)
                            ? firstWord.filter(x => x.toLowerCase().indexOf('my') < 0)
                            : firstWord;

                    if (legalFirstWord.length !== firstWord.length || Math.floor(rnd() * 100) % 7 > 0) {
                        //pick a first word
                        descChain = `${legalFirstWord[Math.floor(rnd() * legalFirstWord.length)]} ${descChain.toLowerCase()}`;
                    }
                    return `${descChain} ${usedTerm0},`;
                };

                this.getGoldenShipOpening = () => {
                    const endearment = [
                        'Princess',
                        'Baby girl',
                        'Babe',
                    ];
                    const endearmentTerm = endearment[Math.floor(rnd() * endearment.length)];
                    const goldenStarTerms = [
                        'Your golden ship',
                        'Your magnificent golden ship',
                        'Your beautiful golden ship',
                        'Your spectacular golden ship',
                        'Your beautiful ship made of magical gold',
                    ];
                    const goldenTerm = goldenStarTerms[Math.floor(rnd() * goldenStarTerms.length)];
                    const phrases = [
                        `${goldenTerm} awaits.`,
                        `${endearmentTerm}, the Golden Star is ready for boarding.`,
                        `${goldenTerm} is ready for you, ${endearmentTerm.toLowerCase()}.`,
                        `${goldenTerm} bobs quietly at the docks, waiting for its princess.`,
                        `${goldenTerm} is ready.`,
                        `Adventure awaits on the Golden Star for you tonight, ${endearmentTerm.toLowerCase()}.`,
                        `The Golden Star is ready for boarding, ${endearmentTerm.toLowerCase()}.`,
                        `${endearmentTerm}, ${goldenTerm.toLowerCase()} is ready for boarding.`,
                        `${goldenTerm} is ready for adventure.`,
                        `Adventure awaits for you tonight, ${endearmentTerm.toLowerCase()}, on ${goldenTerm.toLowerCase()}.`,
                        `The Golden Star is ready for boarding.`,
                        `${goldenTerm} awaits its princess.`,
                        `${goldenTerm} is ready for boarding.`,
                        `Adventure awaits for you tonight on ${goldenTerm.toLowerCase()} ${endearmentTerm.toLowerCase()}.`,
                        `The Golden Star is ready for its princess to board.`,
                        `${goldenTerm} bobs quietly at the docks, waiting for you, ${endearmentTerm.toLowerCase()}.`,
                        `${goldenTerm} is ready to board.`,
                        `I have prepared ${goldenTerm.toLowerCase()} for you ${endearmentTerm.toLowerCase()}.`,
                        `${goldenTerm} is ready for its princess.`,
                    ];
                    return phrases[Math.floor(rnd() * phrases.length)];
                };

                this.getGoodnightOpening = () => {
                    let m = 314592907;
                    const endearment = [
                        'Tonia',
                        'princess',
                        'baby girl',
                        'babe',
                    ];
                    //Remove used term of endearment.
                    if (usedTerm0.length > 0 && endearment.indexOf(usedTerm0) > -1) {
                        endearment.splice(endearment.indexOf(usedTerm0), 1);
                    }

                    usedTerm1 = endearment.splice(Math.floor(rnd() * endearment.length), 1)[0];
                    usedTerm2 = endearment.splice(Math.floor(rnd() * endearment.length), 1)[0];
                    if (Math.floor(rnd() * 10) % 2 === 0) {
                        return `Sweet dreams ${usedTerm1}. Goodnight ${usedTerm2}.`;
                    }
                    return `Goodnight ${usedTerm1}. Sweet dreams ${usedTerm2}.`;
                };

                this.customOrderRoulette = (num) => {
                    const customIdeas = [
                        `I accidentally labeled a video "Confessions and Shows of Affection" and now I'm wondering what that kind of a custom would look like!`,
                        `A random Tonia idea!`,
                        `A face and smile worship video with *lots* of smiles!`,
                        `A broom balancing challenge video! Film yourself practicing and trying to get up to a full thirty seconds! Maybe do it nude just for fun? ðŸ¤­ðŸ˜`,
                        `Another custom involving your incredibly sexy collar bones, this time with smiles! Either a photo set or a video showing you playing with them and different things to put in the indentation. ðŸ¥°`,
                        `A "Where do you see *yourself* in five years?" video. You did a "where will *we* be in five years" video once, but this is just for you. Feel free to include where we might be with our friendship/relationship, but I'm mostly interested in things like where you want to be living, what you hope for career-wise, and what you are thinking as far as love and family are concerned. ðŸ¥°`,
                        `A detailed, up-close pussy worship video, maybe this time employing the dildo I helped you get. ðŸ¥µ`,
                        `Tonia decides!`,
                        `A new apartment tour? ðŸ˜‹`,
                        `Just try to smile at the camera for like 15 minutes. Maybe set a timer or something. lol`,
                        `Do a book review! Maybe a book you loved, or just one you found interesting and can talk about for a long time!`,
                        `Tonia surprises me!`,
                        `Trash-talking something bad! Is there any movie or book you hate with a passion and you can go on and on about how awful/terrible it is? I want to hear *all* of the reasons it's bad! Write them down if you need to just to make sure you have plenty to rant about!`,
                        `Another food review! Pick a dish you haven't tried and tell me all about it while you try it for the first time! ðŸ¥°`,
                        `Whatever Tonia feels like doing!`,
                        `A cooking with Tonia video making a nice lunch/dinner maybe?`,
                        `Another full body worship video going over everything I love about you, but this time with a ponytail and more smiling!`,
                        `Tell me more about yourself! Tell me things I don't already know about you. Things from your memories, things about your everyday life, things that you secretly hope for or wish for. Likes, dislikes. Passions. Dreams. Anything at all!`,
                        `Brush your teeth blindfolded!`,
                        `Tonia makes something she wants to make for me.`,
                        `A series of challenges similar to the photo challenge series but done in succession and on video.`,
                        `A home workout routine, with or without Kaj, with or without clothes. ðŸ¤­`,
                        `Stacking cups in a pyramid on your belly while lying down. How high can you go?`,
                        `A silly but sexy masturbation video (the fan idea from a while ago might work).`,
                    ];

                    return customIdeas[num % customIdeas.length];
                };

                this.spinRoulette = () => {
                    rand1 = rnd();
                    const min = 100;
                    const max = 1000;
                    return Math.floor(rand1 * (max - min)) + min;
                };
            }

            function Builder(state) {
                const r = new BadRando(state);
                const regenerateButtonText = 'Regenerate Message';
                const installmentsToolContainerId = 'installmentsToolContainer';
                const numInstallmentsSelectorId = 'numInstallmentsSelector';
                const maxInstallments = state.getMaxInstallments();

                this.buildMorningMessage = () => {
                    let message = state.getMorningMessage();
                    if (message === null) {
                        message = `${r.getGoodMorning()} ðŸ˜ ${r.getILoveYou()} ðŸ¥°\n\n[my dreams and how I'm feeling]\n\n${r.getQuestions()} ðŸ˜˜`;
                    }
                    const containerDiv = createElement('div', {'style': 'width:512px; margin:16px auto; padding:0px;'}, null);
                    
                    const violationsOutput = createElement('input', {'type': 'text', 'readonly': true, 'style': 'display: none;'}, null);
                    const textArea = createElement('textarea', {'style': 'height:256px;'}, message);
                    textArea.addEventListener('keyup', () => state.saveState());
                    state.connectTextArea(state.stateManagerNames.morning, textArea, null, censorText, violationsOutput);
                    containerDiv.appendChild(textArea);
                    containerDiv.appendChild(violationsOutput);

                    const resetButton = createElement('input', {'type': 'button', 'value': regenerateButtonText}, null);
                    resetButton.addEventListener('click', () => state.reset(state.stateManagerNames.morning), false);
                    containerDiv.appendChild(resetButton);

                    const detail = makeDetail(`Good Morning Message`, containerDiv, state.getMorningDetailOpen() || r.isMorning);
                    detail.childNodes[0].addEventListener('click', () => state.saveState(10), false);
                    state.connectDetail(state.stateManagerNames.morningDetail, detail);

                    return detail;
                };

                this.buildAudioClipMessage = () => {
                    let message = state.getAudioClipMessage();
                    if (message === null) {
                        message = r.getAudioClipQuestion();
                    }
                    const containerDiv = createElement('div', {'style': 'width:512px; margin:16px auto; padding:0px;'}, null);
                    
                    const violationsOutput = createElement('input', {'type': 'text', 'readonly': true, 'style': 'display: none;'}, null);
                    const textArea = createElement('textarea', {'style': 'height:256px;'}, message);
                    textArea.addEventListener('keyup', () => state.saveState());
                    state.connectTextArea(state.stateManagerNames.audioClip, textArea, null, censorText, violationsOutput);
                    containerDiv.appendChild(textArea);
                    containerDiv.appendChild(violationsOutput);

                    const resetButton = createElement('input', {'type': 'button', 'value': regenerateButtonText}, null);
                    resetButton.addEventListener('click', () => state.reset(state.stateManagerNames.audioClip), false);
                    containerDiv.appendChild(resetButton);

                    const detail = makeDetail(`Audio Clip Message`, containerDiv, state.getAudioClipDetailOpen() || r.isAfternoon);
                    detail.childNodes[0].addEventListener('click', () => state.saveState(10), false);
                    state.connectDetail(state.stateManagerNames.audioClipDetail, detail);

                    return detail;
                };

                this.buildGoodnightMessage = () => {
                    let message = state.getGoodnightMessage();
                    if (message === null) {
                        message = `${r.getBedtimeTitles()} [mini love letter]\n\n${r.getGoldenShipOpening()} [golden ship notes]\n\n${r.getGoodnightOpening()} [goodnight sweetness] ðŸ˜˜`;
                    }
                    const containerDiv = createElement('div', {'style': 'width:512px; margin:16px auto; padding:0px;'}, null);
                    
                    const violationsOutput = createElement('input', {'type': 'text', 'readonly': true, 'style': 'display: none;'}, null);
                    const textArea = createElement('textarea', {'style': 'height:256px;'}, message);
                    textArea.addEventListener('keyup', () => state.saveState());
                    state.connectTextArea(state.stateManagerNames.goodnight, textArea, null, censorText, violationsOutput);
                    containerDiv.appendChild(textArea);
                    containerDiv.appendChild(violationsOutput);

                    const resetButton = createElement('input', {'type': 'button', 'value': regenerateButtonText}, null);
                    resetButton.addEventListener('click', () => state.reset(state.stateManagerNames.goodnight), false);
                    containerDiv.appendChild(resetButton);

                    const detail = makeDetail(`Goodnight Message`, containerDiv, state.getGoodnightDetailOpen() || r.isEvening);
                    detail.childNodes[0].addEventListener('click', () => state.saveState(10), false);
                    state.connectDetail(state.stateManagerNames.goodnightDetail, detail);

                    return detail;
                };

                this.buildCustomOrderingTool = () => {
                    const defaultMessage = `Roll to find out what custom you should order next!`;
                    let message = state.getCustomRequestMessage();
                    let textAreaDisabled = false;
                    if (message === null || message === '') {
                        textAreaDisabled = true;
                    }
                    const containerDiv = createElement('div', {'style': 'width:512px; margin:16px auto; padding:0px;'}, null);
                    
                    const textAreaStyle = {'style': 'height:128px;', 'placeholder': defaultMessage};
                    if (textAreaDisabled) {
                        textAreaStyle['disabled'] = true;
                    }

                    const violationsOutput = createElement('input', {'type': 'text', 'readonly': true, 'style': 'display: none;'}, null);
                    const textArea = createElement('textarea', textAreaStyle, message);
                    textArea.addEventListener('keyup', () => state.saveState());
                    state.connectTextArea(state.stateManagerNames.customRequest, textArea, null, censorText, violationsOutput);
                    containerDiv.appendChild(textArea);
                    containerDiv.appendChild(violationsOutput);

                    const rollButton = createElement('input', {'type': 'button', 'value': `Roll!`}, null);
                    rollButton.addEventListener('click', () => spinCustomRoulette(textArea, rollButton), false);
                    containerDiv.appendChild(rollButton);

                    const detail = makeDetail(`Custom Ordering Tool`, containerDiv, state.getCustomDetailOpen());
                    detail.childNodes[0].addEventListener('click', () => state.saveState(10), false);
                    state.connectDetail(state.stateManagerNames.customDetail, detail);

                    return detail;
                };

                const spinCustomRoulette = (textArea, rollButton) => {
                    const spinSpeed = r.spinRoulette();
                    rollButton.value = 'Rolling...';
                    rollButton.disabled = true;
                    textArea.disabled = true;
                    setTimeout(() => animateCustomRoulette(textArea, rollButton, -1, spinSpeed, 1), 100);
                };

                const animateCustomRoulette = (textArea, rollButton, num, speed, friction) => {
                    num += 1;
                    speed -= friction;
                    if (speed <= 0) {
                        textArea.value = r.customOrderRoulette(num);
                        rollButton.value = 'Roll again!';
                        rollButton.disabled = false;
                        textArea.disabled = false;
                        state.saveState(10);
                    }
                    else {
                        textArea.value = r.customOrderRoulette(num);
                        setTimeout(() => animateCustomRoulette(textArea, rollButton, num, speed, friction), 1000 / speed);
                    }
                };
                
                this.buildInstallmentsTool = () => {
                    let numInstallments = state.getNumInstallments();
                    if (numInstallments === null) {
                        numInstallments = 3;
                        state.setNumInstallments(numInstallments);
                    }
                    const tool = createElement('div', {'style': 'padding: 16px;', 'id': installmentsToolContainerId}, null);
                    tool.appendChild(createElement('label', {'for': numInstallmentsSelectorId}, `How many installments?`));
                    const numInstallmentsSelector = createElement('input', {'type': 'number', 'min': '1', 'max': maxInstallments, 'value': numInstallments, 'name': numInstallmentsSelectorId, 'id': numInstallmentsSelectorId});
                    numInstallmentsSelector.addEventListener('keyup', () => state.saveState());
                    numInstallmentsSelector.addEventListener('mouseup', () => state.saveState());
                    state.connectNumberSelector(state.stateManagerNames.numInstallments, numInstallmentsSelector, sanitizeNumInstallments);
                    tool.appendChild(numInstallmentsSelector);
                    const goButton = createElement('input', {'type': 'button', 'value': 'Begin!'});
                    goButton.addEventListener('click', populateInstallmentsTool, false);
                    tool.appendChild(goButton);
                    if (state.installmentsStarted()) {
                        addInstallmentsBoxes(tool);
                    }

                    const detail = makeDetail(`Installments Helper`, tool, state.getInstallmentsDetailOpen() || state.installmentsStarted());
                    detail.childNodes[0].addEventListener('click', () => state.saveState(10), false);
                    state.connectDetail(state.stateManagerNames.installmentsDetail, detail);

                    return detail;
                };

                const sanitizeNumInstallments = (num) => Math.max(1, Math.min(num, maxInstallments));

                const censorText = (text) => {
                    if (text === null || text === undefined) {
                        return [];
                    }
                    const words = text.replaceAll('\n', ' ').split(' ').map(w => removeNonAlphanumeric(w.toLowerCase()));
                    const violations = [];
                    for (const word of words) {
                        if (restrictedWords.indexOf(word) > -1 && !violations.indexOf(word) > -1) {
                            violations.push(word);
                        }
                    }
                    return violations;
                };

                const populateInstallmentsTool = () => {
                    const toolContainer = document.getElementById(installmentsToolContainerId);
                    return addInstallmentsBoxes(toolContainer);
                };

                const addInstallmentsBoxes = (toolContainer) => {
                    const num = state.getNumInstallments();
                    if (toolContainer && num && !isNaN(num) && num > 0) {
                        toolContainer.innerHTML = '';
                        const containerDiv = createElement('div', {'style': 'width:512px; margin:16px auto; padding:0px;'}, null);

                        for (let i = 0; i < num; i++) {
                            let text = state.getInstallmentMessage(i+1);
                            const defaultValue = `${(i+1)}/${num}: `;
                            if (text === null) {
                                text = defaultValue;
                            }

                            const violationsOutput = createElement('input', {'type': 'text', 'readonly': true, 'style': 'display: none;'}, null);
                            const textArea = createElement('textarea', {'style': 'height:256px;'}, text);
                            textArea.addEventListener('keyup', () => state.saveState());
                            state.connectTextArea(state.stateManagerNames[`installment${(i+1)}`], textArea, defaultValue, censorText, violationsOutput);
                            containerDiv.appendChild(textArea);
                            containerDiv.appendChild(violationsOutput);
                            containerDiv.appendChild(createCheckBox(i+1, num, state.stateManagerNames[`installment${(i+1)}Done`]));
                        }

                        const resetButton = createElement('input', {'type': 'button', 'value': 'Reset Installments', 'style': 'background-color:#f4213a; color:#ffecec; font-weight:bold;'}, null);
                        resetButton.addEventListener('click', () => state.reset(state.stateManagerNames.installments), false);
                        containerDiv.appendChild(resetButton);

                        toolContainer.appendChild(containerDiv);
                    }
                };

                const createCheckBox = (num, totalNum, connectTo) => {
                    const frac = `${num}/${totalNum}`;
                    const id = `installment${frac}`;
                    const container = createElement('div', {'style': 'display: flex; flex-direction: row; align-items: baseline; gap: 5px;'}, null);
                    const checkbox = createElement('input', {'type': 'checkbox', 'id': id, 'name': id}, null);
                    checkbox.checked = state.getInstallmentDone(num);
                    state.connectCheckBox(connectTo, checkbox);
                    checkbox.addEventListener('click', () => state.saveState(10));
                    checkbox.addEventListener('keyup', () => state.saveState(10));
                    const label = createElement('label', {'for': id}, `${frac} Delivered`);
                    label.addEventListener('click', () => state.saveState(10));

                    container.appendChild(checkbox);
                    container.appendChild(label);
                    return container;
                };
            }

            function StateManager() {
                const stateDateKey = 'MessageToolStateDate';
                const stateDataKey = 'MessageToolStateData';
                const currentDate = (new Date()).toDateString();
                const maxInstallments = 12;

                this.getMaxInstallments = () => maxInstallments;

                //NOTE: there is probably a better way to handle the installments!
                this.stateManagerNames = {
                    morning: 'morningMessage',
                    morningDetail: 'morningDetail',
                    audioClip: 'audioClipMessage',
                    audioClipDetail: 'audioClipDetail',
                    goodnight: 'goodnightMessage',
                    goodnightDetail: 'goodnightDetail',
                    customRequest: 'customRequestMessage',
                    customDetail: 'customDetail',
                    installments: 'allInstallments',
                    numInstallments: 'numInstallments',
                    installmentsDetail: 'installmentsDetail',
                    installment1: 'installment1Message',
                    installment2: 'installment2Message',
                    installment3: 'installment3Message',
                    installment4: 'installment4Message',
                    installment5: 'installment5Message',
                    installment6: 'installment6Message',
                    installment7: 'installment7Message',
                    installment8: 'installment8Message',
                    installment9: 'installment9Message',
                    installment10: 'installment10Message',
                    installment11: 'installment11Message',
                    installment12: 'installment12Message',
                    installment1Done: 'installment1Done',
                    installment2Done: 'installment2Done',
                    installment3Done: 'installment3Done',
                    installment4Done: 'installment4Done',
                    installment5Done: 'installment5Done',
                    installment6Done: 'installment6Done',
                    installment7Done: 'installment7Done',
                    installment8Done: 'installment8Done',
                    installment9Done: 'installment9Done',
                    installment10Done: 'installment10Done',
                    installment11Done: 'installment11Done',
                    installment12Done: 'installment12Done',
                };
                let stateObj = {};

                for (let n in this.stateManagerNames) {
                    stateObj[this.stateManagerNames[n]] = null;
                }

                const stateManagers = {};

                this.connectTextArea = (key, textArea, defaultValue, cens, vOut) => {
                    stateManagers[key] = new TextAreaStateManager(textArea, defaultValue, cens, vOut);
                };

                this.connectNumberSelector = (key, numSelector, sanitizer) => {
                    stateManagers[key] = new NumberSelectorStateManager(numSelector, sanitizer);
                };

                this.connectDetail = (key, detail) => {
                    stateManagers[key] = new DetailStateManager(detail);
                }

                this.connectCheckBox = (key, checkbox) => {
                    stateManagers[key] = new CheckBoxStateManager(checkbox);
                };

                const loadState = () => {
                    stateObj = JSON.parse(localStorage.getItem(stateDataKey));
                };

                this.saveState = (delay) => {
                    if (delay === null || delay === undefined) {
                        performSave();
                    }
                    else {
                        setTimeout(performSave, delay);
                    }
                };

                const performSave = () => {
                    for (let n in stateManagers) {
                        if (stateManagers.hasOwnProperty(n)) {
                            stateObj[n] = stateManagers[n].getValue();
                            if (n.indexOf('installment') === 0 && n.indexOf('Message') > -1) {
                                stateManagers[n].setDisabled(stateManagers[n.replace('Message', 'Done')].getValue());
                            }
                        }
                    }
                    localStorage.setItem(stateDataKey, JSON.stringify(stateObj));
                };

                this.reset = (key) => {
                    switch (key) {
                        case this.stateManagerNames.installments:
                            if (this.installmentsStarted() && !confirm(`This will delete all installment messages written so far and reset the installments panel. Are you sure?`)) {
                                return;
                            }
                            resetState(this.stateManagerNames.numInstallments);
                            resetState(this.stateManagerNames.installmentsDetail);
                            for (let i = 0; i < maxInstallments; i++) {
                                resetState(this.stateManagerNames[`installment${(i+1)}`]);
                                resetState(this.stateManagerNames[`installment${(i+1)}Done`]);
                            }
                            break;
                        default:
                            resetState(key);
                    }
                    this.saveState();
                    location.reload();
                };

                const resetState = (key) => {
                    stateObj[key] = null;
                    delete stateManagers[key];
                };

                this.getMorningMessage = () => stateObj[this.stateManagerNames.morning];
                this.getMorningDetailOpen = () => stateObj[this.stateManagerNames.morningDetail];

                this.getAudioClipMessage = () => stateObj[this.stateManagerNames.audioClip];
                this.getAudioClipDetailOpen = () => stateObj[this.stateManagerNames.audioClipDetail];

                this.getGoodnightMessage = () => stateObj[this.stateManagerNames.goodnight];
                this.getGoodnightDetailOpen = () => stateObj[this.stateManagerNames.goodnightDetail];
                
                this.getCustomRequestMessage = () => stateObj[this.stateManagerNames.customRequest];
                this.getCustomDetailOpen = () => stateObj[this.stateManagerNames.customDetail];

                this.getInstallmentsDetailOpen = () => stateObj[this.stateManagerNames.installmentsDetail];
                this.getNumInstallments = () => stateObj[this.stateManagerNames.numInstallments];
                this.setNumInstallments = (num) => stateObj[this.stateManagerNames.numInstallments] = num;

                this.getInstallmentMessage = (num) => stateObj[this.stateManagerNames[`installment${num}`]];
                this.getInstallmentDone = (num) => stateObj[this.stateManagerNames[`installment${num}Done`]];
                this.installmentsStarted = () => {
                    for (let i = 0; i < maxInstallments; i++) {
                        if (this.getInstallmentDone(i+1) || this.getInstallmentMessage(i+1) !== null) {
                            return true;
                        }
                    }
                    return false;
                };

                if (localStorage.getItem(stateDateKey) === currentDate) {
                    loadState();
                }
                else {
                    localStorage.setItem(stateDateKey, currentDate);
                    this.saveState();
                }
            }

            function TextAreaStateManager(ta, defVal, cens, vOut) {
                const textArea = ta;
                const defaultValue = defVal;
                const censor = cens;
                const violationsOutput = vOut;
                this.getValue = () => {
                    var returnVal = defaultValue && textArea.value === defaultValue
                        ? null
                        : textArea.value;
                    if (violationsOutput !== null && violationsOutput !== undefined && censor !== null && censor !== undefined) {
                        const violations = censor(returnVal);

                        if (violations.length === 0) {
                            violationsOutput.style.display = 'none';
                            violationsOutput.value = '';
                        }
                        else {
                            violationsOutput.style.display = 'block';
                            violationsOutput.value = `Violation${(violations.length === 1 ? '' : 's')} Detected: ${violations.join(', ')}`;
                        }
                    }
                    return returnVal;
                };
                this.setDisabled = (disabled) => textArea.disabled = disabled;
            }

            function NumberSelectorStateManager(ns, sani) {
                const numberSelector = ns;
                const sanitizer = sani;
                this.getValue = () => sanitizer(parseInt(numberSelector.value));
            }

            function DetailStateManager(dt) {
                const detail = dt;
                this.getValue = () => detail.open || false;
            }

            function CheckBoxStateManager(cb) {
                const checkbox = cb;
                this.getValue = () => checkbox.checked;
            }

            const state = new StateManager();
            const builder = new Builder(state);
            const container = createElement('div', {'style': 'width:600px;height:100%;margin:0px auto;display:flex;flex-wrap:wrap;flex-direction:column;'}, null);
            container.appendChild(createElement('h1', {}, `Messaging Tools`));
            container.appendChild(createElement('h2', {}, `For Use with My Princess`));
            container.appendChild(builder.buildMorningMessage());
            container.appendChild(builder.buildAudioClipMessage());
            container.appendChild(builder.buildGoodnightMessage());
            container.appendChild(builder.buildCustomOrderingTool());
            container.appendChild(builder.buildInstallmentsTool());
            container.appendChild(createElement('h2', {}, `For Use with Everyone Else`));
            container.appendChild(createElement('p', {}, `Coming soon...`));
            document.body.appendChild(container);
            state.saveState();
        </script>
    </body>
</html>